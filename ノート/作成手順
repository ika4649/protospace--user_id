#Deviseを導入し、ユーザー用のモデルおよびテーブルを作成しましょう#
 deviseをGemfileに記述し、bundle installを実行した
 rails g devise:installでdeviseのインストールをした
 rails g devise userでUserモデルを作成した
 マイグレーションファイルに、ユーザー名、プロフィール、所属、役職を追加した
 （メールアドレスとパスワードについてはデフォルトでマイグレーションファイルに記載されているため、追記の必要はない）
 rails db:migrateを実行し、Sequel Pro（windowsの方はDBeaver）でusersテーブルが存在することを確かめた

#バリデーションを設定しましょう#
 Userモデルに各カラムのバリデーションを記述した
 （「emailとpasswordが空だと保存できない」というバリデーションは標準で用意されているため、記述する必要はない）

#ビューファイルを適切なものに置き換えましょう#
 配布済みのviews/deviseディレクトリを既存のviewsディレクトリに置き換えた

#新規登録ができるようにしましょう#
 ヘッダーの「新規登録」ボタンに適切なパスを記載した
 （devise/registrations#newに該当するパスを、rails routesを用いて確認する）
 registrations/new.html.erbのform_withのモデル名と新規登録機能へのパスを正しいものに修正した
 registrations/new.html.erbで「:hoge」と表記されている部分を、正しいものに修正した
 （PicTweetなどの新規登録ページも参考にする）
 application_controllerに、emailとpassword以外の値も保存できるように追記した
 （PicTweetなども参考にする）
 サーバーを再起動し、正しく新規登録ができることを確かめた
 Sequel Pro（Windowsの方はDBeaver）でusersテーブルに情報が保存されていることを確認した

#ヘッダーの表示と、「こんにちは、〇〇さん」の表示がログイン状態か否かで変わるようにしましょう#
 1.ヘッダーの「ログイン」「新規登録」と、「ログアウト」「New Proto」を、
   ログインをしているときとしていないときで表示が変わるように条件分岐した
      app/views/layouts/application.html.erb
          <% if user_signed_in? %>
            <div class="nav__right">
              <%= link_to "ログアウト", root_path, class: :nav__logout %>
              <%= link_to "New Proto", root_path, class: :nav__btn %>
            </div>
          <% else %>
            <div class="nav__right">
              <%= link_to "ログイン", root_path, class: :nav__btn %>
              <%= link_to "新規登録", new_user_registration_path, class: :nav__btn %>
            </div>
          <% end %>
      ログイン状態の確認には、user_signed_in?メソッドを使用します。


 2.ログインしているときは、トップページに「こんにちはユーザー名さん」が表示されるように条件分岐した
 3.「こんにちはユーザー名さん」の「ユーザー名」の部分に、今ログインしているユーザーのユーザー名が表示されるようにした
    
      app/views/prototypes/index.html.erb
          <% if user_signed_in? %>
            <div class="greeting">
              <%= "こんにちは" %>
              <%= link_to "#{current_user.name}さん", root_path, class: :greeting__link%>
            </div> 
          <% end %>
      ログイン状態の確認には、user_signed_in?メソッドを使用します。
      current_user メソッドを使用して現在のユーザーを取得し、そのユーザー名を表示するようにします。
      Deviseを使用している場合、特に追加の設定なしで current_user が利用できます。


#ログイン・ログアウトができるようにしましょう
 1.ヘッダーの「ログイン」ボタンに適切なパスを記載した
 （devise/sessions#newに該当するパスを、rails routesを用いて確認する）
    →該当するパスがnew_user_sessionと確認できた
      application.html.erbを以下に修正
      <%= link_to "ログイン", new_user_session_path, class: :nav__btn %>

 2.ヘッダーの「ログアウト」ボタンに適切なパスを記載した
 （devise/sessions#destroyに該当するパスを、rails routesを用いて確認する。HTTPメソッドの指定に注意。）
    →該当するパスがdestroy_user_sessionと確認できた
      application.html.erbを以下に修正
      <%= link_to "ログアウト", destroy_user_session_path, data: { turbo_method: :delete }, class: :nav__logout %>

      HTTPメソッドのdeleteを指定するためdata: { turbo_method: :delete }と記述すると、
      ログイン時に使用されるdeviseのsessionsコントローラーのdestroyアクションが実行されます。


 3.sessions/new.html.erbのform_withのモデル名とログイン機能へのパスを正しいものに修正した
    sessions/new.html.erbを以下に修正
      <%= form_with model: @user, url: user_session_path, ~~~

 4.sessions/new.html.erbで「:hoge」と表記されている部分を、正しいものに修正した
 （PicTweetなどのログインページも参考にする）
    hoge → email,password

 5.サーバーを再起動し、ブラウザでログアウト/ログインができることを確認した
    ok
 6.情報が正しくない、情報が欠けている場合は、新規登録・ログインができないことを確認した
    ok

#プロトタイプ情報の投稿機能を実装しよう#
#Prototypeモデルおよびテーブルを作成しましょう
 1.rails g model prototypeでPrototypeモデルを作成した

 2.マイグレーションファイルに、プロトタイプの名称、キャッチコピー、コンセプトのためのカラムを追加した
  db/migrate/2024~create_prototypes.rbに以下を追記
      t.string :title
      t.text :catch_copy
      t.text :concept

 3.マイグレーションファイルに、userを参照するための外部キーを記述した（references型を用いる）
  db/migrate/2024~create_prototypes.rbに以下を追記
    t.references :user, null: false, foreign_key: true

  外部キーとは、関連する他のテーブルのレコードの主キーを値とする項目のこと.
  外部キー制約は、t.references :userにforeign_key: trueと記述することで、設定できます。
  referencesという型を使用していますが、これは他テーブルから情報を参照する際に用いる型です。

 4.rails db:migrateを実行し、Sequel Pro（windowsの方はDBeaver）でprototypesテーブルが存在することを確かめた
    OK

#アソシエーションを記述しましょう
 1.Prototypeモデルにアソシエーションを記述した
    app/models/prototype.rbに以下を追記
      belongs_to :user

 2.Userモデルにアソシエーション記述した
    app/models/user.rbに以下を追記
      has_many :prototypes

  アソシエーションとは、モデルを利用したテーブル同士の関連付けのことです。
  アソシエーションをモデルに定義することで、そのモデルに紐づく別のモデルの情報へアクセスできるようになります。

#Active Storageを導入しましょう
 1.mini_magickとimage_processingのGemをGemfileに記述し、bundle installを実行した
 （参考カリキュラムのとおり、image_processingについてはバージョンの指定をする）
    Gemfileに以下を追記
      gem 'mini_magick'
      gem 'image_processing', '~> 1.2'
    bundle installを実行

 2.rails active_storage:installでActive Storageを導入した
    OK
 3.rails db:migrateを実行した
    OK
 4.Prototypeモデルに、has_one_attachedを使用してimageカラムとのアソシエーションを記述した
    app/models/prototype.rbに以下を追記
      has_one_attached :image
    各レコードとファイルを1対1の関係で紐づけるメソッドです。
    has_one_attachedメソッドを記述したモデルの各レコードは、それぞれ1つのファイルを添付できます。

#バリデーションを設定しましょう
 1.Prototypeモデルに、プロトタイプの名称、キャッチコピー、コンセプト、画像に関するバリデーションを記述した
    app/models/prototype.rbに以下を追記
      validates :title,       presence: true
      validates :catch_copy,  presence: true
      validates :concept,     presence: true
      validates :image,       presence: true

#アクションとルーティングを設定しましょう
 1.prototypesコントローラーにnewアクションとcreateアクションを設定した（まだアクション内の処理は書かない）
    prototypes_conroller.rbに以下を追記
      def new end
      def create end

 2.resourcesを用いて、上記で設定したnewアクションとcreateアクションに対するルーティングをroutes.rbに記述した
    routes.rbに以下を追記
      resources :prototypes, only: [:new, :create] 

 3.rails routesを実行して、ルーティングが正しく設定できていることを確かめた
    OK

#適切なビューファイルを設定しましょう
 1.views/prototypesの中に、配布済みのnew.html.erbと_form.html.erbを配置した
    OK

#投稿機能を実装しましょう
 1.ヘッダーの「New Proto」ボタンから、新規投稿ページに遷移するようにパスを設定した（rails routesを用いて確認する）
    app/views/layouts/application.html.erbに以下に修正
      <%= link_to "New Proto", new_prototype_path, ~

 2.newアクションにインスタンス変数@prototypeを定義し、Prototypeモデルの新規オブジェクトを代入した
    prototypes_conroller.rbに以下を追記
      def new
        @prototype = Prototype.new
      end

 3.new.html.erbから部分テンプレートである、_form.html.erbを呼び出す記述をした
    app/views/prototypes/new.html.erb内を以下に修正
      <%= render partial: 'form',  locals:{prototype: @prototype} %> 

 4._form.html.erbのform_withのモデル名を正しいものに修正した
    app/views/prototypes/_form.html.erb内を以下に修正
      <%= form_with model: prototype, local: true do |f|%>

 5._form.html.erbで「:hoge」と記載されている部分を、正しいものに修正した
      ok

 6.prototypesコントローラーのprivateメソッドにストロングパラメーターをセットし、特定の値のみを受け付けるようにした。
 且つ、user_idもmergeした
    prototypes_conroller内に以下を追記
      private

      def prototype_params
        params.require(:prototype).permit(:title, :catch_copy, :concept).merge(user_id: current_user.id)
      end
      このようにして、ストロングパラメーターを用いて指定された属性のみを受け付けつつ、現在のユーザーIDを適切に追加することができます。

 7.createアクションにデータ保存のための記述をし、保存されたときはルートパスに戻るような記述をした
    prototypes_conroller内に以下を追記
      def create
        Prototype.create(prototype_params)
        redirect_to '/'
      end

 8.createアクションに、データが保存されなかったときは新規投稿ページへ戻るようrenderを用いて記述した
    prototypes_conroller内を以下に修正
      def create
        @prototype = Prototype.new(prototype_params)
        if @prototype.save
          redirect_to root_path
        else
          render :new
        end
      end
    新しいPrototypeを作成し、それをデータベースに保存しようとします。
    保存が成功すればルートパスにリダイレクトし、保存に失敗した場合はnewアクションのビューが再レンダリングされます


 9.バリデーションによって保存ができず投稿ページへ戻ってきた場合でも、入力済みの項目（画像以外）は消えないことを確認した
    うまくいかなかったため以下を修正
    prototypes_conroller.rb
      def prototype_params
        params.require(:prototype).permit(:title, :catch_copy, :concept, :image ).merge(user_id: current_user.id)
      end
    :imageを追加

    _form.html.erbを以下に修正
    <%= form_with model: @prototype, local: true do |f|%>
    model: prototype → @prototype に修正

 10.サーバーを再起動し、ブラウザで正しく動くか確認した
    ok
 11.Sequel Pro（Windowsの方はDBeaver）を確認して、正しく保存ができているか確認した
    ok

#投稿したプロトタイプがトップページで表示されるようにしましょう
 1.各プロトタイプを表示するための部分テンプレート_prototype.html.erbを、views/prototypesの中に配置した
    OK
 2.indexアクションに、インスタンス変数@prototypesを定義し、すべてのプロトタイプの情報を代入した
    prototypes_conroller.rbのindexアクションに以下を追記
      @prototypes = Prototype.all

 3.index.html.erbから_prototype.html.erbを呼び出し、
 プロトタイプ毎に、画像・プロトタイプ名・キャッチコピー・投稿者の名前を表示できるようにした
 （renderメソッドにcollectionオプションを用いて実装する）
    index.html.erbを以下に修正
      <div class="card__wrapper">
        <%= render partial: 'prototype', collection: @prototypes %>
      </div>
    collectionオプションは、指定したインスタンス変数の中にある要素の数だけ、
    部分テンプレートを繰り返し呼び出すことができるオプションです。
    collectionオプションを使えば、繰り返し表示させたい要素がインスタンス変数に複数入っている場合でも、
    eachメソッドを使用せずにrenderで繰り返し表示できます。

 4.正しくプロトタイプの表示ができるように、_prototype.html.erbを編集した（ただし仮置きのリンクroot_pathはそのままで良い）
    _prototype.html.erb 修正前
      <div class="card">
        <%= link_to image_tag("プロトタイプの画像", class: :card__img ), root_path%>
        <div class="card__body">
          <%= link_to "プロトタイプのタイトル", root_path, class: :card__title%>
          <p class="card__summary">
            <%= "プロトタイプのキャッチコピー" %>
          </p>
        <%= link_to "by プロトタイプの投稿者名", root_path, class: :card__user %>
        </div>
      </div>
    修正後
      <div class="card">
        <%= link_to image_tag(prototype.image, class: :card__img ), root_path%>
        <div class="card__body">
          <%= link_to prototype.title, root_path, class: :card__title%>
          <p class="card__summary">
            <%= prototype.catch_copy %>
          </p>
          <%= link_to "by #{prototype.user.name}", root_path, class: :card__user %>
        </div>
      </div>
    renderメソッドで_partialsを呼び出すときに:prototypeという変数が各プロトタイプに対応して設定されます。
    そのため、パーシャル内でこれを使用することで各プロトタイプの情報にアクセスできます。

 5.ブラウザで正しく表示されるか確認した
    ok


##プロトタイプの詳細ページを実装しよう
#アクションとルーティングを設定しましょう
 1.prototypesコントローラーにshowアクションを設定した（まだアクション内の処理は書かない）
    def show end

 2.resourcesを用いて、上記で設定したshowアクションに対するルーティングをroutes.rbに記述した
    resources :prototypes, only: [:new, :create, :show] 

 3.rails routesを実行して、ルーティングが正しく設定できていることを確かめた
    OK

#トップページのプロトタイプをクリックすると、詳細ページに遷移するようにしましょう
 1._prototype.html.erbの画像およびプロトタイプ名におけるリンク先が、詳細ページとなるように設定した
    _prototype.html.erbのimageとtitleのroot_pathをprototype_path(prototype)に修正

#詳細ページで投稿の情報が表示されるようにしましょう
 1.showアクションにインスタンス変数@prototypeを定義した。
 且つ、Pathパラメータで送信されるID値で、Prototypeモデルの特定のオブジェクトを取得するように記述し、それを@prototypeに代入した
    prototypes_conroller.rbのshowアクションに以下を追記
      def show
        @prototype = Prototype.find(params[:id])
      end

 2.show.html.erbにおいて、プロトタイプの「プロトタイプ名」「投稿者」「画像」
 「キャッチコピー」「コンセプト」が表示されるように記述を変更した
    show.html.erbを以下に修正
      <%= "プロトタイプのタイトル"%> → <%= @prototype.title %>
      <%= link_to "by プロトタイプの投稿者"~ → <%= link_to "by #{@prototype.user.name}" ~
      <%= image_tag "プロトタイプの画像" %> → <%= image_tag @prototype.image %>
      <%= "プロトタイプのキャッチコピー" %> → <%= @prototype.catch_copy %>
    注意点はprototypeではなくコントローラーで定義したインスタンス変数@prototypeにすること

 3.詳細ページに遷移し、プロトタイプの「プロトタイプ名」「投稿者」「画像」
 「キャッチコピー」「コンセプト」が正しく表示されることを確認した
    OK

#投稿したユーザーだけに「編集」「削除」のボタンが表示されるようにしましょう
 1.ログインしているユーザーがそのプロトタイプの投稿者であるときは、
 「編集」「削除」のボタンが表示されるように条件分岐した（ボタンのリンク先は仮置きのroot_pathのままでよい）
    show.html.erbを以下に修正
    修正前
      <%# プロトタイプの投稿者とログインしているユーザーが同じであれば以下を表示する %>
        <div class="prototype__manage">
          <%= link_to "編集する", root_path, class: :prototype__btn %>
          <%= link_to "削除する", root_path, class: :prototype__btn %>
        </div>
      <%# // プロトタイプの投稿者とログインしているユーザーが同じであれば上記を表示する %>
    修正後
      <% if user_signed_in? && current_user.id == @prototype.user_id %>
        <div class="prototype__manage">
          <%= link_to "編集する", root_path, class: :prototype__btn %>
          <%= link_to "削除する", root_path, class: :prototype__btn %>
        </div>
      <% end %>

 2.ブラウザで正しく動くか確認した
    OK


##プロトタイプ情報の編集機能を実装しよう
#アクションとルーティングを設定しましょう
 1.prototypesコントローラーにeditアクションとupdateアクションを設定した（まだアクション内の処理は書かない）
    def edit end
    def update end

 2.resourcesを用いて、上記で設定したeditアクションとupdateアクションに対するルーティングをroutes.rbに記述した
    resources :prototypes, only: [:new, :create, :show, :edit, :update] 
 
 3.rails routesを実行して、ルーティングが正しく設定できていることを確かめた
    ok

#適切なビューファイルを設定しましょう
 1.views/prototypesの中に、配布済みのedit.html.erbを配置した
    ok

#詳細ページから編集ページに遷移できるようにしましょう
1.show.html.erbの「編集する」ボタンから、編集ページに遷移するようにパスを設定した（パスはrails routesを用いて確認する）
    show.html.erbの編集するボタンのパスを以下に修正
      <%= link_to "編集する", edit_prototype_path(@prototype), ~

#編集機能を実装しましょう
 1.editアクションにインスタンス変数@prototypeを定義した。且つ、Pathパラメータで送信されるID値で、
 Prototypeモデルの特定のオブジェクトを取得するように記述し、それを@prototypeに代入した
    def edit
      @prototype = Prototype.find(params[:id])
    end

 2.edit.html.erbから部分テンプレートである、_form.html.erbを呼び出す記述をした
    edit.html.erbに以下を追記
      <%= render partial: 'form', locals:{prototype: @prototype} %>

 3.updateアクションにデータを更新する記述をし、更新されたときはそのプロトタイプの詳細ページに戻るような記述をした
    def update
      prototype = Prototype.find(paarams[:id])
      prototype.update(prototype_params)
      redirect_to root_path
    end

 4.updateアクションに、データが更新されなかったときは、編集ページに戻るようにrenderを用いて記述した
    def update
      @prototype = Prototype.find(params[:id])
      if @prototype.update(prototype_params)
        redirect_to prototype_path(@prototype)
      else 
        render :edit
      end
    end

 5.バリデーションによって更新ができず編集ページへ戻ってきた場合でも、入力済みの項目（画像以外）は消えないことを確認した
    ok
 6.サーバーを再起動し、ブラウザで正しく動くか確認した
    ok
 7.Sequel Proを確認して、正しく更新ができているか確認した
    ok

##プロトタイプ削除機能を実装しよう
#アクションとルーティングを設定しましょう
 1.prototypesコントローラーにdestroyアクションを設定した（まだアクション内の処理は書かない）
    def destroy end

 2.resourcesを用いて、上記で設定したdestroyアクションに対するルーティングをroutes.rbに記述した
    resources :prototypes, only: [:new, :create, :show, :edit, :update, :destroy]

 3.rails routesを実行して、ルーティングが正しく設定できていることを確かめた
    ok

#詳細ページから削除ボタンをクリックすると投稿が削除できるようにしましょう
 1.show.html.erbの「削除する」ボタンから、先ほど作成したルーティングが呼び込まれるようにした
 （パスはrails routesを用いて確認する。HTTPメソッドに注意する）
    show.html.erbの削除するボタンのパスを以下に修正
      <%= link_to "削除する", prototype_path(@prototype), data: { turbo_method: :delete}, class: :prototype__btn %>

 2.destroyアクションに、プロトタイプを削除し、トップページに戻るような記述をした
    def destroy
      prototype = Prototype.find(params[:id])
      prototype.destroy
      redirect_to root_path
    end

 3.サーバーを再起動し、ブラウザで正しく動くか確認した
    ok

##コメント投稿機能を実装しよう
#Commentモデルおよびテーブルを作成しましょう
 1.rails g model commentでCommentモデルを作成した
    ok
 2.マイグレーションファイルに、テキストのためのカラムを追加した
    db/migrate/2024~_create_comments/rbに以下を追記
      t.text :content

 3.マイグレーションファイルに、userおよびprototypeを参照するための外部キーを記述した（references型を用いる）
    db/migrate/2024~_create_comments/rbに以下を追記
      t.references :user,      null: false, foreign_key: true
      t.references :prototype, null: false, foreign_key: true

 4.rails db:migrateを実行し、Sequel Proでcommentsテーブルが存在することを確かめた
    OK
 5.Commentモデルに、userおよびprototypeに対するアソシエーションを設定した
    app/models/comment.rbに以下を追記
      belongs_to :user
      belongs_to :prototype

 6.UserモデルおよびPrototypeモデルにも、commentに対するアソシエーションを設定した
 （必要に応じてdependent: :destroyオプションを使用した）
    app/models/user.rbに以下を追記
      has_many :prototypes, dependent: :destroy
      has_many :comments, dependent: :destroy

    ユーザーは、複数のコメントを投稿することができるので、
    has_many :モデル複数形と記述することで、アソシエーションを組みます。
    belongs_toは単数形

    app/models/prototype.rbに以下を追記
      has_many   :comments, dependent: :destroy

#コントローラーを作成し、アクションとルーティングを設定しましょう
 1.commentsコントローラーを作成した
    ターミナルにて
      rails g controller comments

 2.commentsコントローラーにcreateアクションを設定した（アクション内の処理は書かない）
    def create end

 3.resourcesを用いて、上記で設定したcreateアクションに対するルーティングをroutes.rbに記述した
    resources :prototypes, only: [:new, :create, :show, :edit, :update, :destroy] do
      resources :commnets, only: :create
    end

     commentsをprototypesのネスト内に配置することで、特定のプロトタイプに対するコメントを管理しやすくします。

 4.rails routesを実行して、ルーティングが正しく設定できていることを確かめた
    ok

#コメント投稿機能を実装しましょう
 1.prototypesコントローラーのshowアクションに、@commentというインスタンス変数を定義し、Commentモデルの新規オブジェクトを代入した
    def show
      @prototype = Prototype.find(params[:id])
      @comment = Comment.new
    end

 2.show.html.erbのコメント投稿フォームを整え、モデル名とhogeとなっている部分を正しい値に変更した
    app/views/prototypes/show.html.erb内を以下に修正
      <%= form_with model: [@prototype, @comment], local: true do |f| %>
    hoge → content
    送信ボタン周りを表示させる

 3.上記のフォームがログインしているユーザーにしか表示されないようにした
    <% if user_signed_in? %> #この部分が追加
      <%= form_with model: [@prototype, @comment], local: true do |f| %>
        <div class="field">
          <%= f.label :content, "コメント" %><br />
          <%= f.text_field :content, id:"comment_content" %>
        </div>
        <div class="actions">
          <%= f.submit "送信する", class: :form__btn  %>
        </div>
      <% end %>
    <% end %> #この部分が追加

 4.commentsコントローラーのprivateメソッドにストロングパラメーターをセットし、特定の値のみを受け付けるようにした。
 且つ、user_idとprototype_idもmergeした
    private

    def comment_params
      params.require(:comment).permit(:content).merge(user_id: current_user.id, prototype_id:params[:prototype_id])
    end

 5.createアクションに、データが保存されたときは詳細ページにリダイレクトされるよう記述をした
    comments_controller.rb
      def create
        comment = Comment.create(comment_params)
        redirect_to "/prototypes/#{cpmment.prototype.id}"
      end

 6.createアクションに、データが保存されなかったときは詳細ページに戻るようrenderを用いて記述した
    def create
      @comment = Comment.new(comment_params)
      if @comment.save
        redirect_to prototype_path(@comment.prototype)
      else
        render 'prototypes/show'
      end
    end

 7.サーバーを再起動し、ブラウザで正しく動くか確認した
    ok
 8.Sequel Pro（Windowsの方はDBeaver）を確認して、正しく保存ができているか確認した
    ok

#投稿したコメントが詳細ページで表示されるようにしましょう
 1.showアクションにインスタンス変数@commentsを定義し、その投稿に紐づくすべてのコメントを代入するための記述をした
    @comments = @prototype.comments.includes(:user)
  prototypesテーブルとcommentsテーブルはアソシエーションが組まれているので、@prototype.commentsとすることで、
  @prototypeへ投稿されたすべてのコメントを取得できます。
  また、ビューでは誰のコメントか明らかにするため、アソシエーションを使ってユーザーのレコードを取得する処理を繰り返します。
  そのときに「N+1問題」が発生してしまうので、includesメソッドを使って、N+1問題を解決している点にも注意してください。

 2.show.html.erbに投稿に紐づくコメントおよびその投稿者を表示する記述をした（ただし仮置きのリンクroot_pathはそのままで良い）
    <ul class="comments_lists">
      <% @comments.each do |comment| %>
        <li class="comments_list">
          <%= comment.content %>
          <%= link_to "by #{comment.user.name}", root_path, class: :comment.user %>
        </li>
      <% end %>
    </ul>

    @commentsには複数のコメントのレコードが入っているので、配列の形をとっています。
    そのため、ビューに表示させるためにはeachメソッドを使って、ひとつひとつのレコードに分解してから表示させます。

 3.ブラウザで正しく表示されるか確認した
   ok


##ユーザー詳細ページを実装しよう
#コントローラーとアクション、ルーティングを設定しましょう
 1.usersコントローラーを作成した
    rails g controller users

 2.usersコントローラーにshowアクションを定義した（まだアクション内の処理は書かない）
    def show end

 3.resourcesを用いて、上記で設定したshowアクションに対するルーティングをroutes.rbに記述した
    resources :users, only: :show

 4.rails routesを実行して、ルーティングが正しく設定できていることを確かめた
    ok

#適切なビューファイルを設置しましょう
 1.views/usersの中に、配布済みのshow.html.erbを配置した
    ok

#各ページのユーザー名をクリックすると、ユーザー詳細ページに遷移するようにしましょう
 1.トップページの「こんにちは〇〇さん」の部分と、各プロトタイプの投稿者の部分から、ユーザー詳細ページへ遷移できるようにパスを設定した
    index.html.erbのroot_pathを以下に修正
      user_path(current_user)

 2.プロトタイプ詳細ページのプロトタイプ投稿者の部分から、ユーザー詳細ページへ遷移できるようにパスを設定した
    _prototype.html.erbのroot_pathを以下に修正
      user_path(prototype.user)

 3.各コメントの投稿者の部分から、ユーザー詳細ページへ遷移できるようにパスを設定した
    show.html.erbのroot_pathを以下に修正
      user_path(comment_user)

#ユーザー詳細ページでユーザーの情報が表示されるようにしましょう
 1. usersコントローラーのshowアクションにインスタンス変数@userを定義した。
 且つ、Pathパラメータで送信されるID値で、Userモデルの特定のオブジェクトを取得するように記述し、それを@userに代入した
    def show
      @user = User.find(params[:id])
    end

 2.ユーザー詳細ページで、ユーザーの各情報が正しく表示できるように修正した
    app/views/users/show.html.erb以下を修正
      <%= "#{@user.name}さんの情報"%> #5行目
      <td class="table__col2"><%= "#{@user.name}" %></td>
      <td class="table__col2"><%= @user.profile %></td>
      <td class="table__col2"><%= @user.occupation %></td>
      <td class="table__col2"><%= @user.position %></td>
      <%= "#{@user.name}さんのプロトタイプ"%> #28行目

 3.ユーザー詳細ページで、そのユーザーが投稿したプロトタイプが表示されるように、_prototype.html.erbの部分テンプレートを呼び出した
 （collectionオプションを使用する）
    app/views/users/show.html.erb以下を修正
      <div class="user__card">
        <%= render partial: 'prototypes/prototype', collection: @prototypes %>
      </div>

    users_controller.rbに以下を追記 
      @prototypes = @user.prototypes

 4.サーバーを再起動して、正しく表示されることを確認した
    ok


##ユーザーによってアクセスできる範囲を制限しよう
#ログインしていないユーザーのページ遷移を制限しましょう
 1.prototypesコントローラーに、authenticate_user!を用いて制限を設けた
 （onlyまたはexceptオプションを用いて特定のアクションのみを指定する）
    prototypes_controller.rbの先頭に以下を記述
      before_action :authenticate_user!, only: [:new, :create, :edit, :update, :destroy]

 2.サーバーを再起動し、ログインしていない状態だと特定のページへのアクセスが制限され、
 ログインページにリダイレクトすることを確認した
    ok

#投稿者以外のユーザーが、投稿者専用のページに遷移できないようにしましょう
 1.prototypesコントローラーにおいて、投稿者以外がeditアクションにアクセスしたらトップページにリダイレクトするように記述した
    prototypes_controller.rbの3行目に以下を記述
      before_action :correct_user, only: [:edit, :update, :destroy]
    prototypes_controller.rbの最後尾にcorrect_userメソッドを作成
      def correct_user
        @prototype = Prototype.find(params[:id])
        unless @prototype.user == current_user
          redirect_to root_path
        end
      end

 2.ブラウザで正しく動くか確認した
    ok


動作確認後、以下がうまくいってなかったので修正
1.コメントフォームを空のまま投稿しようとすると、投稿できずにそのページに留まること
  そのページに留まらず、エラーページに遷移してしまいます。
  comments_controller.rb
    def create
      @comment = Comment.new(comment_params)
      if @comment.save
        redirect_to prototype_path(@comment.prototype)
      else
        @prototype = @comment.prototype
        @comments = @prototype.comments
        render 'prototypes/show'
      end
    end

2.ログイン・ログアウトの状態に関わらず、各ページのユーザー名をクリックすると、ユーザーの詳細ページへ遷移すること
  プロトタイプ詳細ページの投稿者名をクリックすると、トップページに遷移します。
  ユーザーの詳細ページへ遷移するよう修正しましょう。
    prototypes/show.html.erb
      7行目のroot_pathをuser_path(@prototype.user)に修正